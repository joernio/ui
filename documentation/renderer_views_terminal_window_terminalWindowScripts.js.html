<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: renderer/views/terminal_window/terminalWindowScripts.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: renderer/views/terminal_window/terminalWindowScripts.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { Terminal } from 'xterm';
import { FitAddon } from 'xterm-addon-fit';

import iconChevronDown from '../../assets/image/icon-chevron-down.svg';
import { windowActionApi } from '../../assets/js/utils/ipcRenderer';
import { openFile, generateRandomID } from '../../assets/js/utils/scripts';
import {
	terminalVariables as TV,
	printable,
} from '../../assets/js/utils/defaultVariables';

import {
	setHistory,
	setTerminalBusy,
	setQuerySuggestions,
} from '../../store/actions/terminalActions';
import { setHighlightRange } from '../../store/actions/editorActions';
import { enQueueQuery } from '../../store/actions/queryActions';
import { store } from '../../store/configureStore';

import * as TWS from './terminalWindowScripts';

export const { workerPool } = store.getState().query;
export const data_obj = { data: '', cursorPosition: 0, currentBlockID: null };

export const updateData = str => {
	if (str) {
		TWS.data_obj.data = `${TWS.data_obj.data.slice(
			0,
			TWS.data_obj.cursorPosition,
		)}${str}${TWS.data_obj.data.slice(TWS.data_obj.cursorPosition)}`;
	} else {
		TWS.data_obj.data = '';
	}
};

export const updateCursorPosition = value => {
	TWS.data_obj.cursorPosition = value;
};

export const constructInputToWrite = () =>
	TV.clearLine +
	TV.cpgDefaultPrompt +
	TWS.data_obj.data +
	TV.carriageReturn +
	TV.cursorPositionFromStart
		.split('&lt;n>')
		.join(TV.cpgDefaultPrompt.length + TWS.data_obj.cursorPosition);


export const constructOutputToWrite = (prompt, value, isCircuitUI) => {
	if (isCircuitUI) {
		return `&lt;pre>${value}&lt;/pre>`;
	}

	return (
		TV.clearLine +
		(prompt !== null ? prompt : ' ') +
		(value !== null ? value : 'Running script .....')
	);
};

export const handleTerminalMaximizeToggle = bool => ({ isMaximized: !bool });

export const handleResize = fitAddon => {
	fitAddon &amp;&amp; fitAddon.fit();
};

export const handleEmptyWorkspace = (workspace, prev_workspace) => {
	if (workspace &amp;&amp; Object.keys(workspace.projects).length &lt; 1) {
		return { isMaximized: true };
	}
	if (
		workspace &amp;&amp;
		Object.keys(workspace.projects).length > 0 &amp;&amp;
		Object.keys(prev_workspace?.projects ? prev_workspace.projects : {})
			.length &lt; 1
	) {
		return { isMaximized: false };
	}

	return {};
};

export const setSuggestionBoxTrackerContent = el => {
	el.innerText = data_obj.data;
};

export const suggestSimilarQueries = () => {
	const { results } = store.getState().query;
	let query_strings = Object.keys(results);
	query_strings = query_strings.map(key => results[key].query);
	query_strings = query_strings.filter(
		query_string =>
			!!(
				query_string &amp;&amp;
				data_obj.data &amp;&amp;
				query_string.startsWith(data_obj.data)
			),
	);
	query_strings.reverse();
	query_strings = [...new Set(query_strings)]; // remove duplicates
	store.dispatch(setQuerySuggestions(query_strings));
};

export const handleSuggestionClick = async (e, refs, term) => {
	const str = e.target.innerText;
	TWS.updateData(null);
	TWS.updateCursorPosition(0);
	TWS.updateData(str);
	TWS.updateCursorPosition(TWS.data_obj.cursorPosition + str.length);
	await TWS.termWrite(term, TWS.constructInputToWrite());
	TWS.handleWriteToCircuitUIInput(refs);
	refs.circuitUIRef.current.children[1].children[0].focus();
};

export const suggestQueryForXterm = async term => {
	const { query_suggestions } = store.getState().terminal;
	await TWS.termWrite(term, TWS.constructInputToWrite());
	if (query_suggestions.length > 0) {
		let str_to_write = query_suggestions[0].split(data_obj.data)[1];
		str_to_write =
			TV.clearLine +
			TV.cpgDefaultPrompt +
			TWS.data_obj.data +
			TV.formatText
				.split('&lt;n>')
				.join('38;2;169;169;169')
				.split('&lt;o>')
				.join(str_to_write) +
			TV.carriageReturn +
			TV.cursorPositionFromStart
				.split('&lt;n>')
				.join(TV.cpgDefaultPrompt.length + TWS.data_obj.cursorPosition);
		await TWS.termWrite(term, str_to_write);
	}
};

export const handlePrintable = async (term, refs, e) => {
	TWS.updateData(e.key);
	TWS.updateCursorPosition(TWS.data_obj.cursorPosition + e.key.length);
	await TWS.termWrite(term, TWS.constructInputToWrite());
	TWS.handleWriteToCircuitUIInput(refs);
};

export const handleCopyToClipBoard = str => {
	windowActionApi.copyToClipBoard(str);
};

export const handlePasteFromClipBoard = (term, refs) => {
	windowActionApi.pasteFromClipBoard();
	windowActionApi.registerPasteFromClipBoardListener(async str => {
		handlePrintable(term, refs, { key: str });
	});
};

export const handleEnter = async (term, refs) => {
	const query = {
		query: TWS.data_obj.data,
		origin: 'terminal',
		ignore: false,
	};
	store.dispatch(enQueueQuery(query));
	store.dispatch(setTerminalBusy(true));
	await TWS.termWrite(term, TWS.constructInputToWrite());
	await TWS.termWriteLn(term, '');
	TWS.handleWriteToCircuitUIResponse(refs, TWS.data_obj.data, 'query');
	TWS.updateData(null);
	TWS.updateCursorPosition(0);
	TWS.handleWriteToCircuitUIInput(refs);
};

export const handleBackspace = async (term, refs) => {
	const { data } = TWS.data_obj;
	const { cursorPosition } = TWS.data_obj;
	TWS.updateData(null);
	TWS.updateCursorPosition(0);
	TWS.updateData(
		data.slice(0, cursorPosition > 0 ? cursorPosition - 1 : 0) +
			data.slice(cursorPosition),
	);
	TWS.updateCursorPosition(cursorPosition > 0 ? cursorPosition - 1 : 0);
	await TWS.termWrite(term, TWS.constructInputToWrite());
	TWS.handleWriteToCircuitUIInput(refs);
};

export const handleArrowUp = async (term, refs, history, ev) => {
	ev.preventDefault();
	const prev_query = TWS.getPrev(history);
	const new_history = TWS.rotatePrev({ ...history });
	TWS.updateData(null);
	TWS.updateCursorPosition(0);
	TWS.updateData(prev_query.query ? prev_query.query : null);
	TWS.updateCursorPosition(
		prev_query.query
			? TWS.data_obj.cursorPosition + prev_query.query.length
			: 0,
	);
	refs.circuitUIRef.current.children[1].children[0].value = TWS.data_obj.data;
	await TWS.termWrite(term, TWS.constructInputToWrite());
	TWS.handleWriteToCircuitUIInput(refs);
	store.dispatch(setHistory(new_history));
};

export const handleArrowDown = async (term, refs, history, ev) => {
	ev.preventDefault();
	const next_query = TWS.getNext(history);
	const new_history = TWS.rotateNext({ ...history });
	TWS.updateData(null);
	TWS.updateCursorPosition(0);
	TWS.updateData(next_query.query ? next_query.query : null);
	TWS.updateCursorPosition(
		next_query.query
			? TWS.data_obj.cursorPosition + next_query.query.length
			: 0,
	);
	refs.circuitUIRef.current.children[1].children[0].value = TWS.data_obj.data;
	await TWS.termWrite(term, TWS.constructInputToWrite());
	TWS.handleWriteToCircuitUIInput(refs);
	store.dispatch(setHistory(new_history));
};

export const handleArrowLeft = async (term, refs) => {
	TWS.updateCursorPosition(
		TWS.data_obj.cursorPosition > 0 ? TWS.data_obj.cursorPosition - 1 : 0,
	);
	await TWS.termWrite(term, TWS.constructInputToWrite());
	TWS.handleWriteToCircuitUIInput(refs);
};

export const handleArrowRight = async (term, refs) => {
	await TWS.writeSuggestionToXterm(term, refs);
	TWS.updateCursorPosition(
		TWS.data_obj.cursorPosition &lt; TWS.data_obj.data.length
			? TWS.data_obj.cursorPosition + 1
			: TWS.data_obj.data.length,
	);
	await TWS.termWrite(term, TWS.constructInputToWrite());
	TWS.handleWriteToCircuitUIInput(refs);
};

export const handleXTermOnKey = async (term, refs, e) => {
	const ev = e.domEvent;
	const not_combination_keys = !ev.altKey &amp;&amp; !ev.ctrlKey &amp;&amp; !ev.metaKey;
	const { history, busy } = store.getState().terminal;

	if (ev.code === 'KeyC' &amp;&amp; ev.ctrlKey) {
		handleCopyToClipBoard(term.getSelection());
	}

	if (ev.code === 'KeyV' &amp;&amp; ev.ctrlKey &amp;&amp; !busy) {
		handlePasteFromClipBoard(term, refs);
	}

	if (busy) return;

	if (ev.code === 'Enter') {
		await handleEnter(term, refs);
	} else if (ev.code === 'Backspace') {
		await handleBackspace(term, refs);
	} else if (ev.code === 'ArrowUp') {
		await handleArrowUp(term, refs, history, ev);
	} else if (ev.code === 'ArrowDown') {
		await handleArrowDown(term, refs, history, ev);
	} else if (ev.code === 'ArrowLeft') {
		await handleArrowLeft(term, refs);
	} else if (ev.code === 'ArrowRight') {
		await handleArrowRight(term, refs);
	} else if (not_combination_keys &amp;&amp; printable[ev.key]) {
		await handlePrintable(term, refs, ev);
	}
};

export const openXTerm = (refs, term) => {
	if (term) {
		term.onKey(async e => {
			await TWS.handleXTermOnKey(term, refs, e);
			suggestSimilarQueries();
			await suggestQueryForXterm(term);
		});

		term.open(refs.terminalRef.current);
	}
};

export const writeSuggestionToXterm = async (term, refs) => {
	const { query_suggestions } = store.getState().terminal;
	if (
		!(TWS.data_obj.cursorPosition &lt; TWS.data_obj.data.length) &amp;&amp;
		query_suggestions.length > 0
	) {
		const str = query_suggestions[0];
		TWS.updateData(null);
		TWS.updateCursorPosition(0);
		TWS.updateData(str);
		TWS.updateCursorPosition(TWS.data_obj.cursorPosition + str.length);
		await TWS.termWrite(term, TWS.constructInputToWrite());
		TWS.handleWriteToCircuitUIInput(refs);
	}
};

export const termWrite = (term, value) =>
	new Promise(r => term.write(value, r));

export const termWriteLn = (term, value) =>
	new Promise(r => term.writeln(value, r));

export const getNext = history => {
	let next = Object.keys(history.next_queries);
	next = next[next.length - 1];
	next = history.next_queries[next];
	return next || '';
};

export const getPrev = history => {
	let prev = Object.keys(history.prev_queries);
	prev = prev[prev.length - 1];
	prev = history.prev_queries[prev];

	if (prev) {
		return prev;
	}
	return TWS.getNext(history);
};

export const removeOldestQueryFromHistory = (history, prev_keys) => {
	delete history.prev_queries[prev_keys[0]];
	return history;
};

export const addQueryToHistory = (history, queue, key) => {
	while (Object.keys(history.next_queries).length > 0) {
		history = TWS.rotateNext(history);
	}

	history.prev_queries[key] = queue[key];
	return history;
};

export const rotateNext = ({ prev_queries, next_queries }) => {
	prev_queries = { ...prev_queries };
	next_queries = { ...next_queries };

	let next = Object.keys(next_queries);
	next = next[next.length - 1];

	if (next) {
		prev_queries[next] = next_queries[next];
		delete next_queries[next];
	}

	return { prev_queries, next_queries };
};

export const rotatePrev = ({ prev_queries, next_queries }) => {
	prev_queries = { ...prev_queries };
	next_queries = { ...next_queries };

	let prev = Object.keys(prev_queries);
	prev = prev[prev.length - 1];

	if (prev) {
		next_queries[prev] = prev_queries[prev];
		delete prev_queries[prev];
	}

	return { prev_queries, next_queries };
};

export const initFitAddon = term => {
	let fitAddon = null;
	if (term) {
		fitAddon = new FitAddon();
		term.loadAddon(fitAddon);
		fitAddon.fit();
		return fitAddon;
	}
	return fitAddon;
};

/**
 * write query result
 * @param {Object} term
 * @param {Object} refs
 * @param {Object} latest
 * @returns true
 */
export const handleWriteQueryResult = async (term, refs, latest) => {
	TWS.updateData(null);
	TWS.updateCursorPosition(0);

	const res_type = latest.result.stdout
		? 'stdout'
		: latest.result.stderr
		? 'stderr'
		: null;
	const lines = res_type ? latest.result[res_type].split('\n') : [];

	for (let i = 0; i &lt; lines.length; i += 1) {
		// eslint-disable-next-line no-await-in-loop
		await TWS.termWriteLn(term, TWS.constructOutputToWrite(null, lines[i]));
	}

	TWS.handleWriteToCircuitUIResponse(refs, lines.join('\n'), res_type);

	await term.prompt();
	store.dispatch(setTerminalBusy(false));
	return true;
};

/**
 * write script query
 * @param {Object} term
 * @param {Object} refs
 * @param {Object} latest
 */
export const handleWriteScriptQuery = async (term, refs, latest) => {
	const { busy } = store.getState().terminal;

	TWS.updateData(null);
	TWS.updateCursorPosition(0);

	await TWS.termWriteLn(
		term,
		TWS.constructOutputToWrite(TV.cpgDefaultPrompt, latest.query),
	);
	TWS.handleWriteToCircuitUIResponse(refs, latest.query, 'query');

	!busy &amp;&amp; (await term.prompt());
};

/**
 * write query
 * @param {Object} term
 * @param {Object} refs
 * @param {Object} latest
 */
export const handleWriteQuery = async (term, refs, latest) => {
	TWS.updateData(null);
	TWS.updateCursorPosition(0);

	const lines = latest.query.split('\n');

	for (let i = 0; i &lt; lines.length; i += 1) {
		if (i &lt; 1) {
			// eslint-disable-next-line no-await-in-loop
			await TWS.termWriteLn(
				term,
				TWS.constructOutputToWrite(TV.cpgDefaultPrompt, lines[i]),
			);
		} else {
			// eslint-disable-next-line no-await-in-loop
			await TWS.termWriteLn(
				term,
				TWS.constructOutputToWrite(null, lines[i]),
			);
		}
	}

	TWS.handleWriteToCircuitUIResponse(refs, lines.join('\n'), 'query');

	store.dispatch(setTerminalBusy(true));
};

/**
 * init Xterm
 */
export const initXterm = async prefersDarkMode => {
	const term = new Terminal({
		cursorBlink: true,
		theme: {
			background: prefersDarkMode ? '#000000' : '#ffffff',
			foreground: prefersDarkMode ? '#ffffff' : '#000000',
			cursorAccent: prefersDarkMode ? '#ffffff' : '#000000',
			cursor: prefersDarkMode ? '#ffffff' : '#000000',
		},
	});

	const shellprompt = TV.carriageReturn + TV.newLine + TV.cpgDefaultPrompt;

	term.prompt = async () => {
		await TWS.termWrite(term, shellprompt);
	};

	await TWS.termWrite(term, TV.cpgWelcomeScreen);
	await term.prompt();

	return term;
};

/**
 * init circuit ui
 * @param {Object} refs
 * @returns object
 */
export const initCircuitUI = refs => {
	const el = refs.circuitUIRef.current;

	el.children[1].children[0].addEventListener(
		'keydown',
		async e => {
			const { term } = store.getState().terminal;
			await handleXTermOnKey(term, refs, { domEvent: e });
			setSuggestionBoxTrackerContent(
				el.children[1].querySelector('#suggestion-box-tracker'),
			);
			suggestSimilarQueries();
		},
		false,
	);

	el.children[1].children[1].addEventListener(
		'click',
		async () => {
			const { term, busy } = store.getState().terminal;
			if (!busy) {
				await handleEnter(term, refs);
				setSuggestionBoxTrackerContent(
					el.children[1].querySelector('#suggestion-box-tracker'),
				);
				suggestSimilarQueries();
			}
		},
		false,
	);

	return () => {
		el.children[1].children[0].removeEventListener(
			'keydown',
			// eslint-disable-next-line no-undef
			handleInitCircuitUIInputKeyDown, // this is undefined, why does it still work?
		);
		el.children[1].children[1].removeEventListener(
			'click',
			// eslint-disable-next-line no-undef
			handleInitCircuitUIButtonClick, // this is undefined, why does it still work?
		);
	};
};

export const openFileAndGoToLineFromCircuitUI = async ({
	filename,
	lineNumber: startLine,
	lineNumberEnd: endLine,
}) => {
	if (
		filename &amp;&amp;
		filename !== '&lt;empty>' &amp;&amp;
		filename.split('&lt;').length === 1 &amp;&amp;
		startLine &amp;&amp;
		endLine
	) {
		startLine = Number(
			startLine.replace('Some(value = ', '').replace(')', ''),
		);
		endLine = Number(endLine.replace('Some(value = ', '').replace(')', ''));
		await openFile(filename);
		store.dispatch(setHighlightRange({ startLine, endLine }));
	}
};

/**
 * toggle all blocks
 * @param {Object} e
 */
export const handleToggleAllBlocks = e => {
	const collapsed = e.target.getAttribute('data-blocks-collapsed');

	const queryContainers =
		e.target.parentElement.getElementsByClassName('query');
	const responseContainers =
		e.target.parentElement.getElementsByClassName('response');

	if (responseContainers.length) {
		if (collapsed) {
			e.target.removeAttribute('data-blocks-collapsed');
		} else {
			e.target.setAttribute('data-blocks-collapsed', true);
		}
	}
	// eslint-disable-next-line no-restricted-syntax
	for (const el of queryContainers) {
		if (collapsed) {
			el.classList.remove('dropdown');
		} else {
			el.classList.add('dropdown');
		}
	}

	// eslint-disable-next-line no-restricted-syntax
	for (const el of responseContainers) {
		if (collapsed) {
			el.classList.remove('dropdown');
		} else {
			el.classList.add('dropdown');
		}
	}
};

/**
 * Function to toggle the visibility of query response block
 * @param {HTMLCollection} e
 */
export const handleToggleBlock = e => {
	const queryContainer = e.target.parentElement;

	const blockID = queryContainer.getAttribute('data-block-id');

	const responseContainer = queryContainer.parentElement.querySelector(
		`.response[data-block-id='${blockID}']`,
	);

	queryContainer.classList.toggle('dropdown');
	responseContainer.classList.toggle('dropdown');
};

/**
 * toggle all sub blocks
 * @param {Object} e
 */
export const handleToggleAllSubBlocks = e => {
	const collapsed = e.target.getAttribute('data-sub-blocks-collapsed');

	const objectContainers =
		e.target.parentElement.getElementsByClassName('object-container');

	if (objectContainers.length) {
		if (collapsed) {
			e.target.removeAttribute('data-sub-blocks-collapsed');
		} else {
			e.target.setAttribute('data-sub-blocks-collapsed', true);
		}
	}
	// eslint-disable-next-line no-restricted-syntax
	for (const el of objectContainers) {
		if (collapsed) {
			el.classList.remove('dropdown');
		} else {
			el.classList.add('dropdown');
		}
	}
};

/**
 * toggle sub block
 * @param {Object} e
 */
export const handleToggleSubBlock = e => {
	e.target.parentElement.classList.toggle('dropdown');
};

/**
 * handleInsertELementToCircuitUIResponseNode
 * @param {Object} obj
 */
export const handleInsertELementToCircuitUIResponseNode = obj => {
	let { value } = obj;
	const { resultsContainer, valueContainer } = obj;

	if (typeof value === 'string') {
		valueContainer.parentElement.removeChild(
			valueContainer.parentElement.children[0],
		);

		value = TWS.constructOutputToWrite(null, value, true);

		const p = resultsContainer.ownerDocument.createElement('p');
		p.classList.add('content');
		p.innerHTML = value;
		valueContainer.appendChild(p);
	} else {
		const objContainer =
			resultsContainer.ownerDocument.createElement('div');
		objContainer.classList.add('object-container');
		const objTitle = resultsContainer.ownerDocument.createElement('span');
		objTitle.innerHTML = `${value.fullName}()`;
		objTitle.classList.add('object-title');

		objTitle.onclick = () => openFileAndGoToLineFromCircuitUI(value);

		const objToggleIcon =
			resultsContainer.ownerDocument.createElement('img');
		objToggleIcon.setAttribute('src', iconChevronDown);
		objToggleIcon.onclick = handleToggleSubBlock;
		objContainer.append(objTitle, objToggleIcon);

		Object.keys(value).forEach(prop => {
			const objEntryContainer =
				resultsContainer.ownerDocument.createElement('div');
			objEntryContainer.classList.add('object-entry-container');
			const objKey = resultsContainer.ownerDocument.createElement('span');
			objKey.classList.add('object-key');
			const objValue =
				resultsContainer.ownerDocument.createElement('span');
			objKey.innerText = prop;
			objValue.innerText = value[prop];
			objEntryContainer.append(objKey, objValue);
			objContainer.append(objEntryContainer);
		});

		valueContainer.appendChild(objContainer);
	}

	resultsContainer.scrollTop = resultsContainer.scrollHeight;
};

/**
 * handleWriteToCircuitUIResponse
 * @param {Object} refs
 * @param {Object} value
 * @param {Object} res_type
 */
export const handleWriteToCircuitUIResponse = (refs, value, res_type) => {
	const key = generateRandomID();

	let p;
	let valueWrapper;
	let valueContainer;
	const resultsContainer = refs.circuitUIRef.current.children[0];
	const circuitUIResEl =
		resultsContainer.ownerDocument.getElementById('circuit-ui-results');

	const containerDiv = circuitUIResEl.ownerDocument.createElement('div');
	circuitUIResEl.append(containerDiv);

	if (res_type === 'query') {
		const blockToggleIcon =
			circuitUIResEl.ownerDocument.createElement('img');
		blockToggleIcon.classList.toggle('hide-icon');
		blockToggleIcon.setAttribute('src', iconChevronDown);
		blockToggleIcon.onclick = TWS.handleToggleBlock;

		TWS.data_obj.currentBlockID = key;
		containerDiv.setAttribute('data-block-id', key);

		containerDiv.classList.add('query', 'dropdown');
		value = TWS.constructOutputToWrite(null, value, true);
		containerDiv.append(blockToggleIcon);

		p = circuitUIResEl.ownerDocument.createElement('p');
		p.classList.add('content');
		p.innerHTML = value;
		containerDiv.append(p);

		resultsContainer.scrollTop = resultsContainer.scrollHeight;
	} else {
		const queryContainer = circuitUIResEl.querySelector(
			`.query[data-block-id='${TWS.data_obj.currentBlockID}']`,
		);
		queryContainer.querySelector('img').classList.toggle('hide-icon');

		containerDiv.setAttribute('data-block-id', TWS.data_obj.currentBlockID);
		containerDiv.classList.add('response', 'dropdown');

		valueWrapper = circuitUIResEl.ownerDocument.createElement('div');
		valueWrapper.classList.add('value-wrapper');
		valueContainer = circuitUIResEl.ownerDocument.createElement('div');
		valueContainer.classList.add('value-container');

		valueWrapper.append(valueContainer);
		containerDiv.append(valueWrapper);

		if (res_type === 'stderr') {
			value = TWS.constructOutputToWrite(null, value, true);

			const errEl = resultsContainer.ownerDocument.createElement('span');
			errEl.classList.add('error');
			errEl.innerText = 'ERROR';

			const p = resultsContainer.ownerDocument.createElement('p');
			p.classList.add('content');
			p.innerHTML = value;

			p.prepend(errEl);
			valueContainer.appendChild(p);

			resultsContainer.scrollTop = resultsContainer.scrollHeight;
		} else if (res_type === 'stdout') {
			const listContentSeperator = generateRandomID();
			const objValueSeperator = generateRandomID();

			const sideToggleBar =
				circuitUIResEl.ownerDocument.createElement('div');
			sideToggleBar.classList.add('toggle-bar');
			sideToggleBar.onclick = TWS.handleToggleAllSubBlocks;

			valueWrapper.prepend(sideToggleBar);

			const callback = value => {
				window.requestIdleCallback(() =>
					handleInsertELementToCircuitUIResponseNode({
						value,
						resultsContainer,
						valueContainer,
					}),
				);
			};

			/**
			 * Infer if value can potentially require
			 * heavy parsing and is therefore more suitable for the worker process.
			 */
			if (!value.split('List[Method] = List(')[1]) {
				handleInsertELementToCircuitUIResponseNode({
					value,
					resultsContainer,
					valueContainer,
				});
			} else {
				const data = { value, listContentSeperator, objValueSeperator };
				TWS.workerPool.queue(worker =>
					worker
						.parseCircuitUIResponseValue(data)
						.subscribe(callback),
				);
			}
		}
	}
};

/**
 * Function to write to the query input
 * @param {Object} refs
 */
export const handleWriteToCircuitUIInput = refs => {
	const input = refs.circuitUIRef.current.children[1].children[0];
	input.value = TWS.data_obj.data;
	input.setSelectionRange(
		TWS.data_obj.cursorPosition,
		TWS.data_obj.cursorPosition,
	);
	suggestSimilarQueries();
};

/**
 * Function to set terminal height
 * @param {Object} window
 * @param {Object} props
 * @returns a fixed terminal height or the maximum terminal height
 */
export const handleMaximize = (window, props) => {
	if (props.terminal.isMaximized) {
		return {
			terminalHeight: `${
				window.screen.height -
				(Number(props.topNavHeight.split('px')[0]) +
					Number(props.statusBarHeight.split('px')[0]) +
					52)
			}px`,
		};
	}
	return { terminalHeight: '468px' };
};

/**
 * resizeHandler
 * @param {Object} terminalHeight
 * @param {Object} diff
 * @param {Object} props
 * @param {Object} window
 * @returns terminal height
 */
export const resizeHandler = (terminalHeight, diff, props, window) => {
	if (Number(terminalHeight.split('px')[0]) &lt; 218 &amp;&amp; diff &lt; 0) {
		return { terminalHeight: 0 };
	}
	if (Number(terminalHeight.split('px')[0]) &lt; 218 &amp;&amp; diff > 0) {
		return { terminalHeight: '468px' };
	}
	if (
		Number(props.topNavHeight.split('px')[0]) +
			Number(props.statusBarHeight.split('px')[0]) +
			Number(terminalHeight.split('px')[0]) +
			50 &lt;
		window.screen.height
	) {
		return { terminalHeight };
	}
};

/**
 * Add query to history
 * @param {Object} queue
 */
export const handleAddQueryToHistory = queue => {
	let { history } = store.getState().terminal;
	history = {
		prev_queries: { ...history.prev_queries },
		next_queries: { ...history.next_queries },
	};
	let key = Object.keys(queue);
	key = key[key.length - 1];

	if (
		!queue[key].ignore &amp;&amp;
		!history.prev_queries[key] &amp;&amp;
		!history.next_queries[key]
	) {
		history = addQueryToHistory(history, queue, key);

		const prev_keys = Object.keys(history.prev_queries);

		if (prev_keys.length >= 500) {
			history = removeOldestQueryFromHistory(history, prev_keys);
		}

		store.dispatch(setHistory(history));
	}
};

/**
 * Send query result to Xterm
 * @param {Object} results
 * @param {Object} refs
 * @returns the result from handleWriteQueryResult
 */
export const sendQueryResultToXTerm = async (results, refs) => {
	const { term } = store.getState().terminal;

	const latest =
		results[Object.keys(results)[Object.keys(results).length - 1]];

	if (
		term &amp;&amp;
		(latest?.result.stdout || latest?.result.stderr) &amp;&amp;
		!latest?.ignore &amp;&amp;
		latest.post_query_uuid &amp;&amp;
		(latest.workspace || latest.project)
	) {
		return await handleWriteQueryResult(term, refs, latest); // eslint-disable-line no-return-await
	}

	if (
		term &amp;&amp;
		!latest?.ignore &amp;&amp;
		latest?.query &amp;&amp;
		!(latest?.result?.stdout &amp;&amp; latest?.result?.stderr)
	) {
		if (latest.origin === 'script') {
			await handleWriteScriptQuery(term, refs, latest);
		} else if (latest.origin !== 'terminal') {
			await handleWriteQuery(term, refs, latest);
		}
	}
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addRemoveKeyDownKeyUpEvent">addRemoveKeyDownKeyUpEvent</a></li><li><a href="global.html#addToQueue">addToQueue</a></li><li><a href="global.html#addToScriptsQueue">addToScriptsQueue</a></li><li><a href="global.html#addWorkSpaceQueryToQueue">addWorkSpaceQueryToQueue</a></li><li><a href="global.html#areResultsEqual">areResultsEqual</a></li><li><a href="global.html#closeDialog">closeDialog</a></li><li><a href="global.html#closeFile">closeFile</a></li><li><a href="global.html#collectSettingsValues">collectSettingsValues</a></li><li><a href="global.html#contructQueryWithPath">contructQueryWithPath</a></li><li><a href="global.html#countQueries">countQueries</a></li><li><a href="global.html#createFolderJsonModel">createFolderJsonModel</a></li><li><a href="global.html#deleteFile">deleteFile</a></li><li><a href="global.html#discardDialogHandler">discardDialogHandler</a></li><li><a href="global.html#extractLanguageFromString">extractLanguageFromString</a></li><li><a href="global.html#extractWorkSpaceNameAndActiveProject">extractWorkSpaceNameAndActiveProject</a></li><li><a href="global.html#fsToJson">fsToJson</a></li><li><a href="global.html#generateRandomID">generateRandomID</a></li><li><a href="global.html#generateScriptImportQuery">generateScriptImportQuery</a></li><li><a href="global.html#getEditorFilesFromOpenFiles">getEditorFilesFromOpenFiles</a></li><li><a href="global.html#getExtension">getExtension</a></li><li><a href="global.html#getFolderStructureRootPathFromWorkspace">getFolderStructureRootPathFromWorkspace</a></li><li><a href="global.html#getOpenFileName">getOpenFileName</a></li><li><a href="global.html#getRoot">getRoot</a></li><li><a href="global.html#getScriptResult">getScriptResult</a></li><li><a href="global.html#getSettingsInitialValues">getSettingsInitialValues</a></li><li><a href="global.html#getUIIgnoreArr">getUIIgnoreArr</a></li><li><a href="global.html#getWindowHeight">getWindowHeight</a></li><li><a href="global.html#getWindowPosition">getWindowPosition</a></li><li><a href="global.html#handleAddQueryToHistory">handleAddQueryToHistory</a></li><li><a href="global.html#handleAPIQueryError">handleAPIQueryError</a></li><li><a href="global.html#handleCloseProject">handleCloseProject</a></li><li><a href="global.html#handleDeleteProject">handleDeleteProject</a></li><li><a href="global.html#handleDiscard">handleDiscard</a></li><li><a href="global.html#handleFontSizeChange">handleFontSizeChange</a></li><li><a href="global.html#handleInitialTableWidth">handleInitialTableWidth</a></li><li><a href="global.html#handleInsertELementToCircuitUIResponseNode">handleInsertELementToCircuitUIResponseNode</a></li><li><a href="global.html#handleMaximize">handleMaximize</a></li><li><a href="global.html#handleMouseDown">handleMouseDown</a></li><li><a href="global.html#handleMouseOut">handleMouseOut</a></li><li><a href="global.html#handleMouseOver">handleMouseOver</a></li><li><a href="global.html#handleMove">handleMove</a></li><li><a href="global.html#handleOnChange">handleOnChange</a></li><li><a href="global.html#handleOpenFile">handleOpenFile</a></li><li><a href="global.html#handleOpenProject">handleOpenProject</a></li><li><a href="global.html#handleResize">handleResize</a></li><li><a href="global.html#handleSave">handleSave</a></li><li><a href="global.html#handleScrollTop">handleScrollTop</a></li><li><a href="global.html#handleSetToast">handleSetToast</a></li><li><a href="global.html#handleShortcut">handleShortcut</a></li><li><a href="global.html#handleSwitchWorkspace">handleSwitchWorkspace</a></li><li><a href="global.html#handleTerminalToggle">handleTerminalToggle</a></li><li><a href="global.html#handleToggleAllBlocks">handleToggleAllBlocks</a></li><li><a href="global.html#handleToggleAllSubBlocks">handleToggleAllSubBlocks</a></li><li><a href="global.html#handleToggleBlock">handleToggleBlock</a></li><li><a href="global.html#handleToggleFilesVisible">handleToggleFilesVisible</a></li><li><a href="global.html#handleToggleFoldersVisible">handleToggleFoldersVisible</a></li><li><a href="global.html#handleToggleSubBlock">handleToggleSubBlock</a></li><li><a href="global.html#handleWebSocketResponse">handleWebSocketResponse</a></li><li><a href="global.html#handleWriteQuery">handleWriteQuery</a></li><li><a href="global.html#handleWriteQueryResult">handleWriteQueryResult</a></li><li><a href="global.html#handleWriteScriptQuery">handleWriteScriptQuery</a></li><li><a href="global.html#handleWriteToCircuitUIInput">handleWriteToCircuitUIInput</a></li><li><a href="global.html#handleWriteToCircuitUIResponse">handleWriteToCircuitUIResponse</a></li><li><a href="global.html#initCircuitUI">initCircuitUI</a></li><li><a href="global.html#initShortcuts">initShortcuts</a></li><li><a href="global.html#initXterm">initXterm</a></li><li><a href="global.html#isCtrlKeyPressed">isCtrlKeyPressed</a></li><li><a href="global.html#isCtrlKeyUnpressed">isCtrlKeyUnpressed</a></li><li><a href="global.html#isFilePathInQueryResult">isFilePathInQueryResult</a></li><li><a href="global.html#isQueryResultToOpenSynthFile">isQueryResultToOpenSynthFile</a></li><li><a href="global.html#isScriptQueryResultToOpenSynthFile">isScriptQueryResultToOpenSynthFile</a></li><li><a href="global.html#modifyWorkSpaceNameAndActiveProject">modifyWorkSpaceNameAndActiveProject</a></li><li><a href="global.html#mouseTrapGlobalBindig">mouseTrapGlobalBindig</a></li><li><a href="global.html#nFormatter">nFormatter</a></li><li><a href="global.html#openEmptyFile">openEmptyFile</a></li><li><a href="global.html#openFile">openFile</a></li><li><a href="global.html#openProjectExists">openProjectExists</a></li><li><a href="global.html#openShortcutsPage">openShortcutsPage</a></li><li><a href="global.html#openSyntheticFile">openSyntheticFile</a></li><li><a href="global.html#parseKeyBinding">parseKeyBinding</a></li><li><a href="global.html#parseProject">parseProject</a></li><li><a href="global.html#parseProjects">parseProjects</a></li><li><a href="global.html#parseScriptReportJSON">parseScriptReportJSON</a></li><li><a href="global.html#performDeQueueQuery">performDeQueueQuery</a></li><li><a href="global.html#performEnQueueQuery">performEnQueueQuery</a></li><li><a href="global.html#performPeekQueue">performPeekQueue</a></li><li><a href="global.html#performPostQuery">performPostQuery</a></li><li><a href="global.html#performPushResult">performPushResult</a></li><li><a href="global.html#processFiles">processFiles</a></li><li><a href="global.html#processQueryResult">processQueryResult</a></li><li><a href="global.html#processScriptResult">processScriptResult</a></li><li><a href="global.html#queueEmpty">queueEmpty</a></li><li><a href="global.html#readFile">readFile</a></li><li><a href="global.html#refreshOpenFiles">refreshOpenFiles</a></li><li><a href="global.html#registerQueryShortcut">registerQueryShortcut</a></li><li><a href="global.html#removeShortcuts">removeShortcuts</a></li><li><a href="global.html#resizeHandler">resizeHandler</a></li><li><a href="global.html#runQueryWithArgs">runQueryWithArgs</a></li><li><a href="global.html#saveFile">saveFile</a></li><li><a href="global.html#selectFolderStructureRootPath">selectFolderStructureRootPath</a></li><li><a href="global.html#sendQueryResultToXTerm">sendQueryResultToXTerm</a></li><li><a href="global.html#sendWindowsMessage">sendWindowsMessage</a></li><li><a href="global.html#setQueryResult">setQueryResult</a></li><li><a href="global.html#shouldAlertScriptRunSuccessful">shouldAlertScriptRunSuccessful</a></li><li><a href="global.html#shouldProcessQueryResult">shouldProcessQueryResult</a></li><li><a href="global.html#shouldRunQuery">shouldRunQuery</a></li><li><a href="global.html#shouldSwitchFolder">shouldSwitchFolder</a></li><li><a href="global.html#toggleScriptsArgsDialog">toggleScriptsArgsDialog</a></li><li><a href="global.html#unRegisterQueryShortcut">unRegisterQueryShortcut</a></li><li><a href="global.html#updateQueriesStats">updateQueriesStats</a></li><li><a href="global.html#wsDisconnectFromServer">wsDisconnectFromServer</a></li><li><a href="global.html#wsReconnectToServer">wsReconnectToServer</a></li><li><a href="global.html#zoomIn">zoomIn</a></li><li><a href="global.html#zoomOut">zoomOut</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Sat Apr 23 2022 17:12:42 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
